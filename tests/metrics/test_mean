# Copyright Â© 2023 Rameez Ismail - All Rights Reserved
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Author(s): Rameez Ismail
# Email(s):  rameez.ismaeel@gmail.com
#
# This code is adapted from Sonnet by DeepMind:
# https://github.com/deepmind/sonnet
# The project is licensed under the Apache-2.0.
# You may obtain a copy of the license at:
# http://www.apache.org/licenses/LICENSE-2.0

"""Tests for nervox.metrics.Mean."""

import tensorflow as tf
from absl.testing import parameterized
from nervox.metrics import Mean


class TestExponentialMovingAverage(tf.test.TestCase, parameterized.TestCase):
    def testCall(self):
        ema = Mean(momentum=0.5)
        self.assertAllClose(ema(3.0).numpy(), 3.0)
        self.assertAllClose(ema(6.0).numpy(), 5.0)

    def testUpdateAndValue(self):
        ema = Mean(momentum=0.50)
        ema.update(3.0)
        self.assertAllClose(ema.value.numpy(), 3.0, atol=1e-3, rtol=1e-5)
        ema.update(6.0)
        self.assertAllClose(ema.value.numpy(), 5.0, atol=1e-3, rtol=1e-5)

    def testReset(self):
        ema = Mean(momentum=0.90)
        self.assertAllClose(ema(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)
        ema.reset()
        self.assertEqual(ema.value.shape, ())
        self.assertTrue(tf.math.is_nan(ema.value))
        self.assertAllClose(ema(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)

    def testResetVector(self):
        ema = Mean(momentum=0.90, axis=0, keepdims=True)
        random_input = tf.random.normal((1, 5))

        self.assertAllClose(
            ema(random_input).numpy(),
            tf.reduce_mean(random_input, axis=0, keepdims=True),
            atol=1e-3,
            rtol=1e-5,
        )
        ema.reset()
        self.assertEqual(ema.value.shape, (1, 5))
        self.assertTrue(tf.reduce_all(tf.math.is_nan(ema.value)))

        zero_input = tf.zeros((1, 5))
        self.assertAllClose(ema(zero_input).numpy(), tf.zeros((1, 5)))
        self.assertEqual(ema._count.dtype, tf.int64)

    def testValueEqualsLatestUpdate(self):
        ema = Mean(momentum=0.50)
        self.assertAllClose(ema(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)
        self.assertAllClose(ema.value.numpy(), 3.0, atol=1e-3, rtol=1e-5)
        self.assertAllClose(ema(6.0).numpy(), 5.0, atol=1e-3, rtol=1e-5)
        self.assertAllClose(ema.value.numpy(), 5.0, atol=1e-3, rtol=1e-5)

    @parameterized.parameters(True, False)
    def testWithTFFunction(self, autograph):
        ema_1 = Mean(momentum=0.95)
        ema_2 = Mean(momentum=0.95)
        ema_func = tf.function(ema_2, autograph=autograph)
        for _ in range(10):
            x = tf.random.uniform((), 0, 10)
            self.assertAllClose(
                ema_1(x).numpy(), ema_func(x).numpy(), atol=1e-3, rtol=1e-5
            )

    @parameterized.parameters(True, False)
    def testResetWithTFFunction(self, autograph):
        ema = Mean(momentum=0.90)
        ema_func = tf.function(ema, autograph=autograph)
        self.assertAllClose(ema_func(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)
        ema.reset()
        self.assertTrue(tf.math.is_nan(ema.value))
        self.assertAllClose(ema_func(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)

    @parameterized.named_parameters(
        ("2D", [2, 2]), ("3D", [1, 5, 3]), ("4D", [2, 3, 5, 3])
    )
    def testAlternativeShape(self, shape):
        ema = Mean(momentum=0.90, keepdims=True, axis=0)
        value = tf.random.uniform(shape)
        result = ema(value)
        self.assertEqual(((1,) + value.shape[1:]), result.shape)

    @parameterized.named_parameters(
        ("2D", [2, 2], 0), ("3D", [1, 5, 3], (0, 1)), ("4D", [2, 3, 5, 3], (0, 3))
    )
    def testAlternativeShapeAxis(self, shape, axis):
        ema = Mean(momentum=0.90, keepdims=True, axis=axis)
        value = tf.random.uniform(shape)
        result = ema(value)

        dims_to_decimate = tuple([axis]) if isinstance(axis, int) else axis
        dims_to_keep = tuple(set(range(len(shape))) - set(dims_to_decimate))
        updates = [
            shape[index] if index in dims_to_keep else 1
            for index in range(tf.size(shape))
        ]
        expected_shape = tf.scatter_nd(
            [[index] for index in range(tf.size(shape))], updates, [tf.size(shape)]
        )
        self.assertAllEqual(expected_shape, result.shape)


class TestCumulativeMovingAverage(tf.test.TestCase, parameterized.TestCase):
    def testCall(self):
        ema = Mean()
        self.assertAllClose(ema(3.0).numpy(), 3.0)
        self.assertAllClose(ema(7.0).numpy(), 5.0)

    def testUpdateAndValue(self):
        ema = Mean()
        ema.update(3.0)
        self.assertAllClose(ema.value.numpy(), 3.0, atol=1e-3, rtol=1e-5)
        ema.update(7.0)
        self.assertAllClose(ema.value.numpy(), 5.0, atol=1e-3, rtol=1e-5)

    def testReset(self):
        ema = Mean()
        self.assertAllClose(ema(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)
        ema.reset()
        self.assertEqual(ema.value.shape, ())
        self.assertTrue(tf.math.is_nan(ema.value))
        self.assertAllClose(ema(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)

    def testResetVector(self):
        ema = Mean(axis=0, keepdims=True)
        random_input = tf.random.normal((1, 5))

        self.assertAllClose(
            ema(random_input).numpy(),
            tf.reduce_mean(random_input, axis=0, keepdims=True),
            atol=1e-3,
            rtol=1e-5,
        )
        ema.reset()
        self.assertEqual(ema.value.shape, (1, 5))
        self.assertTrue(tf.reduce_all(tf.math.is_nan(ema.value)))

        zero_input = tf.zeros((1, 5))
        self.assertAllClose(ema(zero_input).numpy(), tf.zeros((1, 5)))
        self.assertEqual(ema._count.dtype, tf.int64)

    def testValueEqualsLatestUpdate(self):
        ema = Mean()
        self.assertAllClose(ema(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)
        self.assertAllClose(ema.value.numpy(), 3.0, atol=1e-3, rtol=1e-5)
        self.assertAllClose(ema(7.0).numpy(), 5.0, atol=1e-3, rtol=1e-5)
        self.assertAllClose(ema.value.numpy(), 5.0, atol=1e-3, rtol=1e-5)

    @parameterized.parameters(True, False)
    def testWithTFFunction(self, autograph):
        ema_1 = Mean()
        ema_2 = Mean()
        ema_func = tf.function(ema_2, autograph=autograph)
        for _ in range(10):
            x = tf.random.uniform((), 0, 10)
            self.assertAllClose(
                ema_1(x).numpy(), ema_func(x).numpy(), atol=1e-3, rtol=1e-5
            )

    @parameterized.parameters(True, False)
    def testResetWithTFFunction(self, autograph):
        ema = Mean()
        ema_func = tf.function(ema, autograph=autograph)
        self.assertAllClose(ema_func(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)
        ema.reset()
        self.assertTrue(tf.math.is_nan(ema.value))
        self.assertAllClose(ema_func(3.0).numpy(), 3.0, atol=1e-3, rtol=1e-5)

    @parameterized.named_parameters(
        ("2D", [2, 2]), ("3D", [1, 5, 3]), ("4D", [2, 3, 5, 3])
    )
    def testAlternativeShape(self, shape):
        ema = Mean(keepdims=True, axis=0)
        value = tf.random.uniform(shape)
        result = ema(value)
        self.assertEqual(((1,) + value.shape[1:]), result.shape)

    @parameterized.named_parameters(
        ("2D", [2, 2], 0), ("3D", [1, 5, 3], (0, 1)), ("4D", [2, 3, 5, 3], (0, 3))
    )
    def testAlternativeShapeAxis(self, shape, axis):
        ema = Mean(keepdims=True, axis=axis)
        value = tf.random.uniform(shape)
        result = ema(value)

        dims_to_decimate = tuple([axis]) if isinstance(axis, int) else axis
        dims_to_keep = tuple(set(range(len(shape))) - set(dims_to_decimate))
        updates = [
            shape[index] if index in dims_to_keep else 1
            for index in range(tf.size(shape))
        ]
        expected_shape = tf.scatter_nd(
            [[index] for index in range(tf.size(shape))], updates, [tf.size(shape)]
        )
        self.assertAllEqual(expected_shape, result.shape)


if __name__ == "__main__":
    tf.test.main()
